// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'config.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `build_credential_with_key`, `commit`, `load_for_group`, `load_global`, `load_group`

/// Extract the group ID from an MLS protocol message.
///
/// Useful for routing incoming messages to the right group before calling
/// `process_message`. Returns an error if the message is not a protocol
/// message (i.e. it's a Welcome, GroupInfo, or KeyPackage).
Uint8List mlsMessageExtractGroupId({required List<int> messageBytes}) => RustLib
    .instance
    .api
    .crateApiEngineMlsMessageExtractGroupId(messageBytes: messageBytes);

/// Extract the epoch from an MLS protocol message.
///
/// Returns an error if the message is not a protocol message.
BigInt mlsMessageExtractEpoch({required List<int> messageBytes}) => RustLib
    .instance
    .api
    .crateApiEngineMlsMessageExtractEpoch(messageBytes: messageBytes);

/// Get the content type of an MLS protocol message as a string.
///
/// Returns one of: "application", "proposal", "commit".
/// Returns an error if the message is not a protocol message.
String mlsMessageContentType({required List<int> messageBytes}) => RustLib
    .instance
    .api
    .crateApiEngineMlsMessageContentType(messageBytes: messageBytes);

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MlsEngine>>
abstract class MlsEngine implements RustOpaqueInterface {
  Future<AddMembersResult> addMembers({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required List<Uint8List> keyPackagesBytes,
  });

  Future<AddMembersResult> addMembersWithoutUpdate({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required List<Uint8List> keyPackagesBytes,
  });

  Future<void> clearPendingCommit({required List<int> groupIdBytes});

  Future<void> clearPendingProposals({required List<int> groupIdBytes});

  Future<CommitResult> commitToPendingProposals({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
  });

  static Future<MlsEngine> create({
    required String dbPath,
    required List<int> encryptionKey,
  }) => RustLib.instance.api.crateApiEngineMlsEngineCreate(
    dbPath: dbPath,
    encryptionKey: encryptionKey,
  );

  Future<CreateGroupResult> createGroup({
    required MlsGroupConfig config,
    required List<int> signerBytes,
    required List<int> credentialIdentity,
    required List<int> signerPublicKey,
    Uint8List? groupId,
    Uint8List? credentialBytes,
  });

  Future<CreateGroupResult> createGroupWithBuilder({
    required MlsGroupConfig config,
    required List<int> signerBytes,
    required List<int> credentialIdentity,
    required List<int> signerPublicKey,
    Uint8List? groupId,
    BigInt? lifetimeSeconds,
    List<MlsExtension>? groupContextExtensions,
    List<MlsExtension>? leafNodeExtensions,
    MlsCapabilities? capabilities,
    Uint8List? credentialBytes,
  });

  Future<KeyPackageResult> createKeyPackage({
    required MlsCiphersuite ciphersuite,
    required List<int> signerBytes,
    required List<int> credentialIdentity,
    required List<int> signerPublicKey,
    Uint8List? credentialBytes,
  });

  Future<KeyPackageResult> createKeyPackageWithOptions({
    required MlsCiphersuite ciphersuite,
    required List<int> signerBytes,
    required List<int> credentialIdentity,
    required List<int> signerPublicKey,
    required KeyPackageOptions options,
    Uint8List? credentialBytes,
  });

  Future<CreateMessageResult> createMessage({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required List<int> message,
    Uint8List? aad,
  });

  Future<void> deleteGroup({required List<int> groupIdBytes});

  Future<void> deleteKeyPackage({required List<int> keyPackageRefBytes});

  Future<MlsGroupContextInfo> exportGroupContext({
    required List<int> groupIdBytes,
  });

  Future<Uint8List> exportGroupInfo({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
  });

  Future<Uint8List> exportRatchetTree({required List<int> groupIdBytes});

  Future<Uint8List> exportSecret({
    required List<int> groupIdBytes,
    required String label,
    required List<int> context,
    required int keyLength,
  });

  Future<CommitResult> flexibleCommit({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required FlexibleCommitOptions options,
  });

  Future<Uint8List?> getPastResumptionPsk({
    required List<int> groupIdBytes,
    required BigInt epoch,
  });

  Future<MlsCiphersuite> groupCiphersuite({required List<int> groupIdBytes});

  Future<GroupConfigurationResult> groupConfiguration({
    required List<int> groupIdBytes,
  });

  Future<Uint8List> groupConfirmationTag({required List<int> groupIdBytes});

  Future<Uint8List> groupCredential({required List<int> groupIdBytes});

  Future<BigInt> groupEpoch({required List<int> groupIdBytes});

  Future<Uint8List> groupEpochAuthenticator({required List<int> groupIdBytes});

  Future<Uint8List> groupExtensions({required List<int> groupIdBytes});

  Future<bool> groupHasPendingProposals({required List<int> groupIdBytes});

  Future<Uint8List> groupId({required List<int> groupIdBytes});

  Future<bool> groupIsActive({required List<int> groupIdBytes});

  Future<MlsMemberInfo?> groupMemberAt({
    required List<int> groupIdBytes,
    required int leafIndex,
  });

  Future<int?> groupMemberLeafIndex({
    required List<int> groupIdBytes,
    required List<int> credentialBytes,
  });

  Future<List<MlsMemberInfo>> groupMembers({required List<int> groupIdBytes});

  Future<int> groupOwnIndex({required List<int> groupIdBytes});

  Future<MlsLeafNodeInfo> groupOwnLeafNode({required List<int> groupIdBytes});

  Future<List<MlsPendingProposalInfo>> groupPendingProposals({
    required List<int> groupIdBytes,
  });

  Future<WelcomeInspectResult> inspectWelcome({
    required MlsGroupConfig config,
    required List<int> welcomeBytes,
  });

  Future<ExternalJoinResult> joinGroupExternalCommit({
    required MlsGroupConfig config,
    required List<int> groupInfoBytes,
    Uint8List? ratchetTreeBytes,
    required List<int> signerBytes,
    required List<int> credentialIdentity,
    required List<int> signerPublicKey,
    Uint8List? credentialBytes,
  });

  Future<ExternalJoinResult> joinGroupExternalCommitV2({
    required MlsGroupConfig config,
    required List<int> groupInfoBytes,
    Uint8List? ratchetTreeBytes,
    required List<int> signerBytes,
    required List<int> credentialIdentity,
    required List<int> signerPublicKey,
    Uint8List? aad,
    required bool skipLifetimeValidation,
    Uint8List? credentialBytes,
  });

  Future<JoinGroupResult> joinGroupFromWelcome({
    required MlsGroupConfig config,
    required List<int> welcomeBytes,
    Uint8List? ratchetTreeBytes,
    required List<int> signerBytes,
  });

  Future<JoinGroupResult> joinGroupFromWelcomeWithOptions({
    required MlsGroupConfig config,
    required List<int> welcomeBytes,
    Uint8List? ratchetTreeBytes,
    required List<int> signerBytes,
    required bool skipLifetimeValidation,
  });

  Future<LeaveGroupResult> leaveGroup({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
  });

  Future<LeaveGroupResult> leaveGroupViaSelfRemove({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
  });

  Future<void> mergePendingCommit({required List<int> groupIdBytes});

  Future<ProcessedMessageResult> processMessage({
    required List<int> groupIdBytes,
    required List<int> messageBytes,
  });

  Future<ProcessedMessageInspectResult> processMessageWithInspect({
    required List<int> groupIdBytes,
    required List<int> messageBytes,
  });

  Future<ProposalResult> proposeAdd({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required List<int> keyPackageBytes,
  });

  Future<ProposalResult> proposeCustomProposal({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required int proposalType,
    required List<int> payload,
  });

  Future<ProposalResult> proposeExternalPsk({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required List<int> pskId,
    required List<int> pskNonce,
  });

  Future<ProposalResult> proposeGroupContextExtensions({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required List<MlsExtension> extensions,
  });

  Future<ProposalResult> proposeRemove({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required int memberIndex,
  });

  Future<ProposalResult> proposeRemoveMemberByCredential({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required List<int> credentialBytes,
  });

  Future<ProposalResult> proposeSelfUpdate({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    MlsCapabilities? leafNodeCapabilities,
    List<MlsExtension>? leafNodeExtensions,
  });

  Future<CommitResult> removeMembers({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required List<int> memberIndices,
  });

  Future<void> removePendingProposal({
    required List<int> groupIdBytes,
    required List<int> proposalRefBytes,
  });

  Future<CommitResult> selfUpdate({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
  });

  Future<CommitResult> selfUpdateWithNewSigner({
    required List<int> groupIdBytes,
    required List<int> oldSignerBytes,
    required List<int> newSignerBytes,
    required List<int> newCredentialIdentity,
    required List<int> newSignerPublicKey,
    Uint8List? newCredentialBytes,
  });

  Future<void> setConfiguration({
    required List<int> groupIdBytes,
    required MlsGroupConfig config,
  });

  Future<AddMembersResult> swapMembers({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required List<int> removeIndices,
    required List<Uint8List> addKeyPackagesBytes,
  });

  Future<CommitResult> updateGroupContextExtensions({
    required List<int> groupIdBytes,
    required List<int> signerBytes,
    required List<MlsExtension> extensions,
  });
}

class AddMembersResult {
  final Uint8List commit;
  final Uint8List welcome;
  final Uint8List? groupInfo;

  const AddMembersResult({
    required this.commit,
    required this.welcome,
    this.groupInfo,
  });

  @override
  int get hashCode => commit.hashCode ^ welcome.hashCode ^ groupInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddMembersResult &&
          runtimeType == other.runtimeType &&
          commit == other.commit &&
          welcome == other.welcome &&
          groupInfo == other.groupInfo;
}

class CommitResult {
  final Uint8List commit;
  final Uint8List? welcome;
  final Uint8List? groupInfo;

  const CommitResult({required this.commit, this.welcome, this.groupInfo});

  @override
  int get hashCode => commit.hashCode ^ welcome.hashCode ^ groupInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CommitResult &&
          runtimeType == other.runtimeType &&
          commit == other.commit &&
          welcome == other.welcome &&
          groupInfo == other.groupInfo;
}

class CreateGroupResult {
  final Uint8List groupId;

  const CreateGroupResult({required this.groupId});

  @override
  int get hashCode => groupId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateGroupResult &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId;
}

class CreateMessageResult {
  final Uint8List ciphertext;

  const CreateMessageResult({required this.ciphertext});

  @override
  int get hashCode => ciphertext.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateMessageResult &&
          runtimeType == other.runtimeType &&
          ciphertext == other.ciphertext;
}

class ExternalJoinResult {
  final Uint8List groupId;
  final Uint8List commit;
  final Uint8List? groupInfo;

  const ExternalJoinResult({
    required this.groupId,
    required this.commit,
    this.groupInfo,
  });

  @override
  int get hashCode => groupId.hashCode ^ commit.hashCode ^ groupInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExternalJoinResult &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          commit == other.commit &&
          groupInfo == other.groupInfo;
}

class GroupConfigurationResult {
  final MlsCiphersuite ciphersuite;
  final MlsWireFormatPolicy wireFormatPolicy;
  final int paddingSize;
  final int senderRatchetMaxOutOfOrder;
  final int senderRatchetMaxForwardDistance;

  const GroupConfigurationResult({
    required this.ciphersuite,
    required this.wireFormatPolicy,
    required this.paddingSize,
    required this.senderRatchetMaxOutOfOrder,
    required this.senderRatchetMaxForwardDistance,
  });

  @override
  int get hashCode =>
      ciphersuite.hashCode ^
      wireFormatPolicy.hashCode ^
      paddingSize.hashCode ^
      senderRatchetMaxOutOfOrder.hashCode ^
      senderRatchetMaxForwardDistance.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupConfigurationResult &&
          runtimeType == other.runtimeType &&
          ciphersuite == other.ciphersuite &&
          wireFormatPolicy == other.wireFormatPolicy &&
          paddingSize == other.paddingSize &&
          senderRatchetMaxOutOfOrder == other.senderRatchetMaxOutOfOrder &&
          senderRatchetMaxForwardDistance ==
              other.senderRatchetMaxForwardDistance;
}

class JoinGroupResult {
  final Uint8List groupId;

  const JoinGroupResult({required this.groupId});

  @override
  int get hashCode => groupId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is JoinGroupResult &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId;
}

class KeyPackageResult {
  final Uint8List keyPackageBytes;

  const KeyPackageResult({required this.keyPackageBytes});

  @override
  int get hashCode => keyPackageBytes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyPackageResult &&
          runtimeType == other.runtimeType &&
          keyPackageBytes == other.keyPackageBytes;
}

class LeaveGroupResult {
  final Uint8List message;

  const LeaveGroupResult({required this.message});

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LeaveGroupResult &&
          runtimeType == other.runtimeType &&
          message == other.message;
}

class ProcessedMessageInspectResult {
  final ProcessedMessageType messageType;
  final int? senderIndex;
  final BigInt epoch;
  final Uint8List? applicationMessage;
  final StagedCommitInfo? stagedCommitInfo;
  final MlsProposalType? proposalType;

  const ProcessedMessageInspectResult({
    required this.messageType,
    this.senderIndex,
    required this.epoch,
    this.applicationMessage,
    this.stagedCommitInfo,
    this.proposalType,
  });

  @override
  int get hashCode =>
      messageType.hashCode ^
      senderIndex.hashCode ^
      epoch.hashCode ^
      applicationMessage.hashCode ^
      stagedCommitInfo.hashCode ^
      proposalType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProcessedMessageInspectResult &&
          runtimeType == other.runtimeType &&
          messageType == other.messageType &&
          senderIndex == other.senderIndex &&
          epoch == other.epoch &&
          applicationMessage == other.applicationMessage &&
          stagedCommitInfo == other.stagedCommitInfo &&
          proposalType == other.proposalType;
}

class ProcessedMessageResult {
  final ProcessedMessageType messageType;
  final int? senderIndex;
  final BigInt epoch;
  final Uint8List? applicationMessage;
  final bool hasStagedCommit;
  final bool hasProposal;
  final MlsProposalType? proposalType;

  const ProcessedMessageResult({
    required this.messageType,
    this.senderIndex,
    required this.epoch,
    this.applicationMessage,
    required this.hasStagedCommit,
    required this.hasProposal,
    this.proposalType,
  });

  @override
  int get hashCode =>
      messageType.hashCode ^
      senderIndex.hashCode ^
      epoch.hashCode ^
      applicationMessage.hashCode ^
      hasStagedCommit.hashCode ^
      hasProposal.hashCode ^
      proposalType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProcessedMessageResult &&
          runtimeType == other.runtimeType &&
          messageType == other.messageType &&
          senderIndex == other.senderIndex &&
          epoch == other.epoch &&
          applicationMessage == other.applicationMessage &&
          hasStagedCommit == other.hasStagedCommit &&
          hasProposal == other.hasProposal &&
          proposalType == other.proposalType;
}

class ProposalResult {
  final Uint8List proposalMessage;

  const ProposalResult({required this.proposalMessage});

  @override
  int get hashCode => proposalMessage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProposalResult &&
          runtimeType == other.runtimeType &&
          proposalMessage == other.proposalMessage;
}
