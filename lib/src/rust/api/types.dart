// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `capabilities_to_native`, `ciphersuite_to_native`, `extensions_from_mls`, `native_to_ciphersuite`, `wire_format_to_native`

/// Returns the list of supported ciphersuites.
List<MlsCiphersuite> supportedCiphersuites() =>
    RustLib.instance.api.crateApiTypesSupportedCiphersuites();

/// Options for the flexible commit builder.
class FlexibleCommitOptions {
  /// TLS-serialized KeyPackages to add.
  final List<Uint8List> addKeyPackages;

  /// Leaf indices to remove.
  final Uint32List removeIndices;

  /// Force a self-update even if no other proposals.
  final bool forceSelfUpdate;

  /// Whether to consume pending proposals from the store (default: true).
  final bool consumePendingProposals;

  /// Group context extensions to propose.
  final List<MlsExtension>? groupContextExtensions;

  /// Additional authenticated data.
  final Uint8List? aad;

  /// Whether to create a GroupInfo message (default: true).
  final bool createGroupInfo;

  /// Whether to include the ratchet tree extension in GroupInfo.
  final bool useRatchetTreeExtension;

  const FlexibleCommitOptions({
    required this.addKeyPackages,
    required this.removeIndices,
    required this.forceSelfUpdate,
    required this.consumePendingProposals,
    this.groupContextExtensions,
    this.aad,
    required this.createGroupInfo,
    required this.useRatchetTreeExtension,
  });

  @override
  int get hashCode =>
      addKeyPackages.hashCode ^
      removeIndices.hashCode ^
      forceSelfUpdate.hashCode ^
      consumePendingProposals.hashCode ^
      groupContextExtensions.hashCode ^
      aad.hashCode ^
      createGroupInfo.hashCode ^
      useRatchetTreeExtension.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlexibleCommitOptions &&
          runtimeType == other.runtimeType &&
          addKeyPackages == other.addKeyPackages &&
          removeIndices == other.removeIndices &&
          forceSelfUpdate == other.forceSelfUpdate &&
          consumePendingProposals == other.consumePendingProposals &&
          groupContextExtensions == other.groupContextExtensions &&
          aad == other.aad &&
          createGroupInfo == other.createGroupInfo &&
          useRatchetTreeExtension == other.useRatchetTreeExtension;
}

/// Options for creating a key package with the builder API.
class KeyPackageOptions {
  /// Lifetime in seconds. None = default (90 days).
  final BigInt? lifetimeSeconds;

  /// Mark as last-resort key package.
  final bool lastResort;

  /// Custom capabilities. None = defaults.
  final MlsCapabilities? capabilities;

  /// Extensions on the leaf node.
  final List<MlsExtension>? leafNodeExtensions;

  /// Extensions on the key package itself.
  final List<MlsExtension>? keyPackageExtensions;

  const KeyPackageOptions({
    this.lifetimeSeconds,
    required this.lastResort,
    this.capabilities,
    this.leafNodeExtensions,
    this.keyPackageExtensions,
  });

  @override
  int get hashCode =>
      lifetimeSeconds.hashCode ^
      lastResort.hashCode ^
      capabilities.hashCode ^
      leafNodeExtensions.hashCode ^
      keyPackageExtensions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyPackageOptions &&
          runtimeType == other.runtimeType &&
          lifetimeSeconds == other.lifetimeSeconds &&
          lastResort == other.lastResort &&
          capabilities == other.capabilities &&
          leafNodeExtensions == other.leafNodeExtensions &&
          keyPackageExtensions == other.keyPackageExtensions;
}

/// Capabilities advertised by a leaf node.
///
/// All fields are lists of u16 values representing the supported types.
/// Empty lists mean "use defaults".
class MlsCapabilities {
  /// Supported protocol versions (1 = MLS 1.0).
  final Uint16List versions;

  /// Supported ciphersuites.
  final Uint16List ciphersuites;

  /// Supported extension types.
  final Uint16List extensions;

  /// Supported proposal types.
  final Uint16List proposals;

  /// Supported credential types.
  final Uint16List credentials;

  const MlsCapabilities({
    required this.versions,
    required this.ciphersuites,
    required this.extensions,
    required this.proposals,
    required this.credentials,
  });

  @override
  int get hashCode =>
      versions.hashCode ^
      ciphersuites.hashCode ^
      extensions.hashCode ^
      proposals.hashCode ^
      credentials.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MlsCapabilities &&
          runtimeType == other.runtimeType &&
          versions == other.versions &&
          ciphersuites == other.ciphersuites &&
          extensions == other.extensions &&
          proposals == other.proposals &&
          credentials == other.credentials;
}

/// MLS ciphersuite selection.
enum MlsCiphersuite {
  mls128DhkemX25519Aes128GcmSha256Ed25519,
  mls128DhkemX25519Chacha20Poly1305Sha256Ed25519,
  mls128DhkemP256Aes128GcmSha256P256,
}

/// An MLS extension (type + data).
class MlsExtension {
  final int extensionType;
  final Uint8List data;

  const MlsExtension({required this.extensionType, required this.data});

  @override
  int get hashCode => extensionType.hashCode ^ data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MlsExtension &&
          runtimeType == other.runtimeType &&
          extensionType == other.extensionType &&
          data == other.data;
}

/// Full group context information.
class MlsGroupContextInfo {
  final Uint8List groupId;
  final BigInt epoch;
  final MlsCiphersuite ciphersuite;
  final Uint8List treeHash;
  final Uint8List confirmedTranscriptHash;
  final Uint8List extensions;

  const MlsGroupContextInfo({
    required this.groupId,
    required this.epoch,
    required this.ciphersuite,
    required this.treeHash,
    required this.confirmedTranscriptHash,
    required this.extensions,
  });

  @override
  int get hashCode =>
      groupId.hashCode ^
      epoch.hashCode ^
      ciphersuite.hashCode ^
      treeHash.hashCode ^
      confirmedTranscriptHash.hashCode ^
      extensions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MlsGroupContextInfo &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          epoch == other.epoch &&
          ciphersuite == other.ciphersuite &&
          treeHash == other.treeHash &&
          confirmedTranscriptHash == other.confirmedTranscriptHash &&
          extensions == other.extensions;
}

/// Full information about the own leaf node.
class MlsLeafNodeInfo {
  /// TLS-serialized Credential. Deserialize with `MlsCredential.deserialize()`.
  final Uint8List credential;
  final Uint8List signatureKey;
  final Uint8List encryptionKey;
  final MlsCapabilities capabilities;
  final List<MlsExtension> extensions;

  const MlsLeafNodeInfo({
    required this.credential,
    required this.signatureKey,
    required this.encryptionKey,
    required this.capabilities,
    required this.extensions,
  });

  @override
  int get hashCode =>
      credential.hashCode ^
      signatureKey.hashCode ^
      encryptionKey.hashCode ^
      capabilities.hashCode ^
      extensions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MlsLeafNodeInfo &&
          runtimeType == other.runtimeType &&
          credential == other.credential &&
          signatureKey == other.signatureKey &&
          encryptionKey == other.encryptionKey &&
          capabilities == other.capabilities &&
          extensions == other.extensions;
}

/// Information about a group member.
class MlsMemberInfo {
  final int index;

  /// TLS-serialized Credential. Deserialize with `MlsCredential.deserialize()`.
  final Uint8List credential;
  final Uint8List signatureKey;

  const MlsMemberInfo({
    required this.index,
    required this.credential,
    required this.signatureKey,
  });

  @override
  int get hashCode =>
      index.hashCode ^ credential.hashCode ^ signatureKey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MlsMemberInfo &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          credential == other.credential &&
          signatureKey == other.signatureKey;
}

/// Information about a pending proposal in the group.
class MlsPendingProposalInfo {
  /// The type of proposal.
  final MlsProposalType proposalType;

  /// Sender's leaf index (if sender is a group member).
  final int? senderIndex;

  const MlsPendingProposalInfo({required this.proposalType, this.senderIndex});

  @override
  int get hashCode => proposalType.hashCode ^ senderIndex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MlsPendingProposalInfo &&
          runtimeType == other.runtimeType &&
          proposalType == other.proposalType &&
          senderIndex == other.senderIndex;
}

/// MLS proposal types.
enum MlsProposalType {
  add,
  remove,
  update,
  preSharedKey,
  reinit,
  externalInit,
  groupContextExtensions,
  custom,
}

/// Wire format policy for MLS messages.
enum MlsWireFormatPolicy { plaintext, ciphertext }

/// Type of a processed incoming message.
enum ProcessedMessageType { application, proposal, stagedCommit }

/// Information about a staged commit before merging.
class StagedCommitInfo {
  /// TLS-serialized Credentials of members being added.
  final List<Uint8List> addCredentials;

  /// Leaf indices of members being removed.
  final Uint32List removeIndices;

  /// Whether a self-update is included.
  final bool hasUpdate;

  /// Whether the local member was removed.
  final bool selfRemoved;

  /// Number of PSK proposals.
  final int pskCount;

  const StagedCommitInfo({
    required this.addCredentials,
    required this.removeIndices,
    required this.hasUpdate,
    required this.selfRemoved,
    required this.pskCount,
  });

  @override
  int get hashCode =>
      addCredentials.hashCode ^
      removeIndices.hashCode ^
      hasUpdate.hashCode ^
      selfRemoved.hashCode ^
      pskCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StagedCommitInfo &&
          runtimeType == other.runtimeType &&
          addCredentials == other.addCredentials &&
          removeIndices == other.removeIndices &&
          hasUpdate == other.hasUpdate &&
          selfRemoved == other.selfRemoved &&
          pskCount == other.pskCount;
}

/// Information extracted from a Welcome message before joining.
class WelcomeInspectResult {
  /// The group ID the Welcome is for.
  final Uint8List groupId;

  /// The ciphersuite used by the group.
  final MlsCiphersuite ciphersuite;

  /// Number of PSKs required to join.
  final int pskCount;

  /// The group epoch at time of Welcome.
  final BigInt epoch;

  const WelcomeInspectResult({
    required this.groupId,
    required this.ciphersuite,
    required this.pskCount,
    required this.epoch,
  });

  @override
  int get hashCode =>
      groupId.hashCode ^
      ciphersuite.hashCode ^
      pskCount.hashCode ^
      epoch.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WelcomeInspectResult &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          ciphersuite == other.ciphersuite &&
          pskCount == other.pskCount &&
          epoch == other.epoch;
}
