// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'config.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `build_credential_with_key`, `load_group`, `make_provider`

Future<KeyPackageProviderResult> createKeyPackage({
  required MlsCiphersuite ciphersuite,
  required List<int> signerBytes,
  required List<int> credentialIdentity,
  required List<int> signerPublicKey,
  Uint8List? credentialBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderCreateKeyPackage(
  ciphersuite: ciphersuite,
  signerBytes: signerBytes,
  credentialIdentity: credentialIdentity,
  signerPublicKey: signerPublicKey,
  credentialBytes: credentialBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<KeyPackageProviderResult> createKeyPackageWithOptions({
  required MlsCiphersuite ciphersuite,
  required List<int> signerBytes,
  required List<int> credentialIdentity,
  required List<int> signerPublicKey,
  required KeyPackageOptions options,
  Uint8List? credentialBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderCreateKeyPackageWithOptions(
  ciphersuite: ciphersuite,
  signerBytes: signerBytes,
  credentialIdentity: credentialIdentity,
  signerPublicKey: signerPublicKey,
  options: options,
  credentialBytes: credentialBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<CreateGroupProviderResult> createGroup({
  required MlsGroupConfig config,
  required List<int> signerBytes,
  required List<int> credentialIdentity,
  required List<int> signerPublicKey,
  Uint8List? groupId,
  Uint8List? credentialBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderCreateGroup(
  config: config,
  signerBytes: signerBytes,
  credentialIdentity: credentialIdentity,
  signerPublicKey: signerPublicKey,
  groupId: groupId,
  credentialBytes: credentialBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<CreateGroupProviderResult> createGroupWithBuilder({
  required MlsGroupConfig config,
  required List<int> signerBytes,
  required List<int> credentialIdentity,
  required List<int> signerPublicKey,
  Uint8List? groupId,
  BigInt? lifetimeSeconds,
  List<MlsExtension>? groupContextExtensions,
  List<MlsExtension>? leafNodeExtensions,
  MlsCapabilities? capabilities,
  Uint8List? credentialBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderCreateGroupWithBuilder(
  config: config,
  signerBytes: signerBytes,
  credentialIdentity: credentialIdentity,
  signerPublicKey: signerPublicKey,
  groupId: groupId,
  lifetimeSeconds: lifetimeSeconds,
  groupContextExtensions: groupContextExtensions,
  leafNodeExtensions: leafNodeExtensions,
  capabilities: capabilities,
  credentialBytes: credentialBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<JoinGroupProviderResult> joinGroupFromWelcome({
  required MlsGroupConfig config,
  required List<int> welcomeBytes,
  Uint8List? ratchetTreeBytes,
  required List<int> signerBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderJoinGroupFromWelcome(
  config: config,
  welcomeBytes: welcomeBytes,
  ratchetTreeBytes: ratchetTreeBytes,
  signerBytes: signerBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<JoinGroupProviderResult> joinGroupFromWelcomeWithOptions({
  required MlsGroupConfig config,
  required List<int> welcomeBytes,
  Uint8List? ratchetTreeBytes,
  required List<int> signerBytes,
  required bool skipLifetimeValidation,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderJoinGroupFromWelcomeWithOptions(
  config: config,
  welcomeBytes: welcomeBytes,
  ratchetTreeBytes: ratchetTreeBytes,
  signerBytes: signerBytes,
  skipLifetimeValidation: skipLifetimeValidation,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<WelcomeInspectResult> inspectWelcome({
  required MlsGroupConfig config,
  required List<int> welcomeBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderInspectWelcome(
  config: config,
  welcomeBytes: welcomeBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<ExternalJoinProviderResult> joinGroupExternalCommit({
  required MlsGroupConfig config,
  required List<int> groupInfoBytes,
  Uint8List? ratchetTreeBytes,
  required List<int> signerBytes,
  required List<int> credentialIdentity,
  required List<int> signerPublicKey,
  Uint8List? credentialBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderJoinGroupExternalCommit(
  config: config,
  groupInfoBytes: groupInfoBytes,
  ratchetTreeBytes: ratchetTreeBytes,
  signerBytes: signerBytes,
  credentialIdentity: credentialIdentity,
  signerPublicKey: signerPublicKey,
  credentialBytes: credentialBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<ExternalJoinProviderResult> joinGroupExternalCommitV2({
  required MlsGroupConfig config,
  required List<int> groupInfoBytes,
  Uint8List? ratchetTreeBytes,
  required List<int> signerBytes,
  required List<int> credentialIdentity,
  required List<int> signerPublicKey,
  Uint8List? aad,
  required bool skipLifetimeValidation,
  Uint8List? credentialBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderJoinGroupExternalCommitV2(
  config: config,
  groupInfoBytes: groupInfoBytes,
  ratchetTreeBytes: ratchetTreeBytes,
  signerBytes: signerBytes,
  credentialIdentity: credentialIdentity,
  signerPublicKey: signerPublicKey,
  aad: aad,
  skipLifetimeValidation: skipLifetimeValidation,
  credentialBytes: credentialBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<Uint8List> groupId({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupId(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<BigInt> groupEpoch({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupEpoch(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<bool> groupIsActive({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupIsActive(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<List<MlsMemberInfo>> groupMembers({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupMembers(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<MlsCiphersuite> groupCiphersuite({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupCiphersuite(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<int> groupOwnIndex({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupOwnIndex(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<Uint8List> groupCredential({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupCredential(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<Uint8List> groupExtensions({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupExtensions(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<List<MlsPendingProposalInfo>> groupPendingProposals({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupPendingProposals(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<bool> groupHasPendingProposals({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupHasPendingProposals(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<MlsMemberInfo?> groupMemberAt({
  required List<int> groupIdBytes,
  required int leafIndex,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupMemberAt(
  groupIdBytes: groupIdBytes,
  leafIndex: leafIndex,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<int?> groupMemberLeafIndex({
  required List<int> groupIdBytes,
  required List<int> credentialBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupMemberLeafIndex(
  groupIdBytes: groupIdBytes,
  credentialBytes: credentialBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<Uint8List> exportRatchetTree({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderExportRatchetTree(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<Uint8List> exportGroupInfo({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderExportGroupInfo(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<Uint8List> exportSecret({
  required List<int> groupIdBytes,
  required String label,
  required List<int> context,
  required int keyLength,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderExportSecret(
  groupIdBytes: groupIdBytes,
  label: label,
  context: context,
  keyLength: keyLength,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<MlsGroupContextInfo> exportGroupContext({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderExportGroupContext(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<Uint8List> groupConfirmationTag({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupConfirmationTag(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<MlsLeafNodeInfo> groupOwnLeafNode({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupOwnLeafNode(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<Uint8List?> getPastResumptionPsk({
  required List<int> groupIdBytes,
  required BigInt epoch,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGetPastResumptionPsk(
  groupIdBytes: groupIdBytes,
  epoch: epoch,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<AddMembersProviderResult> addMembers({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required List<Uint8List> keyPackagesBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderAddMembers(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  keyPackagesBytes: keyPackagesBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<AddMembersProviderResult> addMembersWithoutUpdate({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required List<Uint8List> keyPackagesBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderAddMembersWithoutUpdate(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  keyPackagesBytes: keyPackagesBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<CommitProviderResult> removeMembers({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required List<int> memberIndices,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderRemoveMembers(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  memberIndices: memberIndices,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<CommitProviderResult> selfUpdate({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderSelfUpdate(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<CommitProviderResult> selfUpdateWithNewSigner({
  required List<int> groupIdBytes,
  required List<int> oldSignerBytes,
  required List<int> newSignerBytes,
  required List<int> newCredentialIdentity,
  required List<int> newSignerPublicKey,
  Uint8List? newCredentialBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderSelfUpdateWithNewSigner(
  groupIdBytes: groupIdBytes,
  oldSignerBytes: oldSignerBytes,
  newSignerBytes: newSignerBytes,
  newCredentialIdentity: newCredentialIdentity,
  newSignerPublicKey: newSignerPublicKey,
  newCredentialBytes: newCredentialBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<AddMembersProviderResult> swapMembers({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required List<int> removeIndices,
  required List<Uint8List> addKeyPackagesBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderSwapMembers(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  removeIndices: removeIndices,
  addKeyPackagesBytes: addKeyPackagesBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<LeaveGroupProviderResult> leaveGroup({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderLeaveGroup(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<LeaveGroupProviderResult> leaveGroupViaSelfRemove({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderLeaveGroupViaSelfRemove(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<ProposalProviderResult> proposeAdd({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required List<int> keyPackageBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderProposeAdd(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  keyPackageBytes: keyPackageBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<ProposalProviderResult> proposeRemove({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required int memberIndex,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderProposeRemove(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  memberIndex: memberIndex,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<ProposalProviderResult> proposeSelfUpdate({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  MlsCapabilities? leafNodeCapabilities,
  List<MlsExtension>? leafNodeExtensions,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderProposeSelfUpdate(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  leafNodeCapabilities: leafNodeCapabilities,
  leafNodeExtensions: leafNodeExtensions,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<ProposalProviderResult> proposeExternalPsk({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required List<int> pskId,
  required List<int> pskNonce,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderProposeExternalPsk(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  pskId: pskId,
  pskNonce: pskNonce,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<ProposalProviderResult> proposeGroupContextExtensions({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required List<MlsExtension> extensions,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderProposeGroupContextExtensions(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  extensions: extensions,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<ProposalProviderResult> proposeCustomProposal({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required int proposalType,
  required List<int> payload,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderProposeCustomProposal(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  proposalType: proposalType,
  payload: payload,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<ProposalProviderResult> proposeRemoveMemberByCredential({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required List<int> credentialBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderProposeRemoveMemberByCredential(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  credentialBytes: credentialBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<CommitProviderResult> commitToPendingProposals({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderCommitToPendingProposals(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<void> mergePendingCommit({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderMergePendingCommit(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<void> clearPendingCommit({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderClearPendingCommit(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<void> clearPendingProposals({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderClearPendingProposals(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<void> setConfiguration({
  required List<int> groupIdBytes,
  required MlsGroupConfig config,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderSetConfiguration(
  groupIdBytes: groupIdBytes,
  config: config,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<CommitProviderResult> updateGroupContextExtensions({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required List<MlsExtension> extensions,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderUpdateGroupContextExtensions(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  extensions: extensions,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<CommitProviderResult> flexibleCommit({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required FlexibleCommitOptions options,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderFlexibleCommit(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  options: options,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<CreateMessageProviderResult> createMessage({
  required List<int> groupIdBytes,
  required List<int> signerBytes,
  required List<int> message,
  Uint8List? aad,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderCreateMessage(
  groupIdBytes: groupIdBytes,
  signerBytes: signerBytes,
  message: message,
  aad: aad,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<ProcessedMessageProviderResult> processMessage({
  required List<int> groupIdBytes,
  required List<int> messageBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderProcessMessage(
  groupIdBytes: groupIdBytes,
  messageBytes: messageBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<ProcessedMessageInspectProviderResult> processMessageWithInspect({
  required List<int> groupIdBytes,
  required List<int> messageBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderProcessMessageWithInspect(
  groupIdBytes: groupIdBytes,
  messageBytes: messageBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<void> deleteGroup({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderDeleteGroup(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<void> deleteKeyPackage({
  required List<int> keyPackageRefBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderDeleteKeyPackage(
  keyPackageRefBytes: keyPackageRefBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<void> removePendingProposal({
  required List<int> groupIdBytes,
  required List<int> proposalRefBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderRemovePendingProposal(
  groupIdBytes: groupIdBytes,
  proposalRefBytes: proposalRefBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<Uint8List> groupEpochAuthenticator({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupEpochAuthenticator(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

Future<GroupConfigurationResult> groupConfiguration({
  required List<int> groupIdBytes,
  required FutureOr<Uint8List?> Function(Uint8List) storageRead,
  required FutureOr<void> Function(Uint8List, Uint8List) storageWrite,
  required FutureOr<void> Function(Uint8List) storageDelete,
}) => RustLib.instance.api.crateApiProviderGroupConfiguration(
  groupIdBytes: groupIdBytes,
  storageRead: storageRead,
  storageWrite: storageWrite,
  storageDelete: storageDelete,
);

/// Extract the group ID from an MLS protocol message.
///
/// Useful for routing incoming messages to the right group before calling
/// `process_message`. Returns an error if the message is not a protocol
/// message (i.e. it's a Welcome, GroupInfo, or KeyPackage).
Uint8List mlsMessageExtractGroupId({required List<int> messageBytes}) => RustLib
    .instance
    .api
    .crateApiProviderMlsMessageExtractGroupId(messageBytes: messageBytes);

/// Extract the epoch from an MLS protocol message.
///
/// Returns an error if the message is not a protocol message.
BigInt mlsMessageExtractEpoch({required List<int> messageBytes}) => RustLib
    .instance
    .api
    .crateApiProviderMlsMessageExtractEpoch(messageBytes: messageBytes);

/// Get the content type of an MLS protocol message as a string.
///
/// Returns one of: "application", "proposal", "commit".
/// Returns an error if the message is not a protocol message.
String mlsMessageContentType({required List<int> messageBytes}) => RustLib
    .instance
    .api
    .crateApiProviderMlsMessageContentType(messageBytes: messageBytes);

class AddMembersProviderResult {
  final Uint8List commit;
  final Uint8List welcome;
  final Uint8List? groupInfo;

  const AddMembersProviderResult({
    required this.commit,
    required this.welcome,
    this.groupInfo,
  });

  @override
  int get hashCode => commit.hashCode ^ welcome.hashCode ^ groupInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddMembersProviderResult &&
          runtimeType == other.runtimeType &&
          commit == other.commit &&
          welcome == other.welcome &&
          groupInfo == other.groupInfo;
}

class CommitProviderResult {
  final Uint8List commit;
  final Uint8List? welcome;
  final Uint8List? groupInfo;

  const CommitProviderResult({
    required this.commit,
    this.welcome,
    this.groupInfo,
  });

  @override
  int get hashCode => commit.hashCode ^ welcome.hashCode ^ groupInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CommitProviderResult &&
          runtimeType == other.runtimeType &&
          commit == other.commit &&
          welcome == other.welcome &&
          groupInfo == other.groupInfo;
}

class CreateGroupProviderResult {
  final Uint8List groupId;

  const CreateGroupProviderResult({required this.groupId});

  @override
  int get hashCode => groupId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateGroupProviderResult &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId;
}

class CreateMessageProviderResult {
  final Uint8List ciphertext;

  const CreateMessageProviderResult({required this.ciphertext});

  @override
  int get hashCode => ciphertext.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateMessageProviderResult &&
          runtimeType == other.runtimeType &&
          ciphertext == other.ciphertext;
}

class ExternalJoinProviderResult {
  final Uint8List groupId;
  final Uint8List commit;
  final Uint8List? groupInfo;

  const ExternalJoinProviderResult({
    required this.groupId,
    required this.commit,
    this.groupInfo,
  });

  @override
  int get hashCode => groupId.hashCode ^ commit.hashCode ^ groupInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExternalJoinProviderResult &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          commit == other.commit &&
          groupInfo == other.groupInfo;
}

class GroupConfigurationResult {
  final MlsCiphersuite ciphersuite;
  final MlsWireFormatPolicy wireFormatPolicy;
  final int paddingSize;
  final int senderRatchetMaxOutOfOrder;
  final int senderRatchetMaxForwardDistance;

  const GroupConfigurationResult({
    required this.ciphersuite,
    required this.wireFormatPolicy,
    required this.paddingSize,
    required this.senderRatchetMaxOutOfOrder,
    required this.senderRatchetMaxForwardDistance,
  });

  @override
  int get hashCode =>
      ciphersuite.hashCode ^
      wireFormatPolicy.hashCode ^
      paddingSize.hashCode ^
      senderRatchetMaxOutOfOrder.hashCode ^
      senderRatchetMaxForwardDistance.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupConfigurationResult &&
          runtimeType == other.runtimeType &&
          ciphersuite == other.ciphersuite &&
          wireFormatPolicy == other.wireFormatPolicy &&
          paddingSize == other.paddingSize &&
          senderRatchetMaxOutOfOrder == other.senderRatchetMaxOutOfOrder &&
          senderRatchetMaxForwardDistance ==
              other.senderRatchetMaxForwardDistance;
}

class JoinGroupProviderResult {
  final Uint8List groupId;

  const JoinGroupProviderResult({required this.groupId});

  @override
  int get hashCode => groupId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is JoinGroupProviderResult &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId;
}

class KeyPackageProviderResult {
  final Uint8List keyPackageBytes;

  const KeyPackageProviderResult({required this.keyPackageBytes});

  @override
  int get hashCode => keyPackageBytes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KeyPackageProviderResult &&
          runtimeType == other.runtimeType &&
          keyPackageBytes == other.keyPackageBytes;
}

class LeaveGroupProviderResult {
  final Uint8List message;

  const LeaveGroupProviderResult({required this.message});

  @override
  int get hashCode => message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LeaveGroupProviderResult &&
          runtimeType == other.runtimeType &&
          message == other.message;
}

class ProcessedMessageInspectProviderResult {
  final ProcessedMessageType messageType;
  final int? senderIndex;
  final BigInt epoch;
  final Uint8List? applicationMessage;
  final StagedCommitInfo? stagedCommitInfo;
  final MlsProposalType? proposalType;

  const ProcessedMessageInspectProviderResult({
    required this.messageType,
    this.senderIndex,
    required this.epoch,
    this.applicationMessage,
    this.stagedCommitInfo,
    this.proposalType,
  });

  @override
  int get hashCode =>
      messageType.hashCode ^
      senderIndex.hashCode ^
      epoch.hashCode ^
      applicationMessage.hashCode ^
      stagedCommitInfo.hashCode ^
      proposalType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProcessedMessageInspectProviderResult &&
          runtimeType == other.runtimeType &&
          messageType == other.messageType &&
          senderIndex == other.senderIndex &&
          epoch == other.epoch &&
          applicationMessage == other.applicationMessage &&
          stagedCommitInfo == other.stagedCommitInfo &&
          proposalType == other.proposalType;
}

class ProcessedMessageProviderResult {
  final ProcessedMessageType messageType;
  final int? senderIndex;
  final BigInt epoch;
  final Uint8List? applicationMessage;
  final bool hasStagedCommit;
  final bool hasProposal;
  final MlsProposalType? proposalType;

  const ProcessedMessageProviderResult({
    required this.messageType,
    this.senderIndex,
    required this.epoch,
    this.applicationMessage,
    required this.hasStagedCommit,
    required this.hasProposal,
    this.proposalType,
  });

  @override
  int get hashCode =>
      messageType.hashCode ^
      senderIndex.hashCode ^
      epoch.hashCode ^
      applicationMessage.hashCode ^
      hasStagedCommit.hashCode ^
      hasProposal.hashCode ^
      proposalType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProcessedMessageProviderResult &&
          runtimeType == other.runtimeType &&
          messageType == other.messageType &&
          senderIndex == other.senderIndex &&
          epoch == other.epoch &&
          applicationMessage == other.applicationMessage &&
          hasStagedCommit == other.hasStagedCommit &&
          hasProposal == other.hasProposal &&
          proposalType == other.proposalType;
}

class ProposalProviderResult {
  final Uint8List proposalMessage;

  const ProposalProviderResult({required this.proposalMessage});

  @override
  int get hashCode => proposalMessage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProposalProviderResult &&
          runtimeType == other.runtimeType &&
          proposalMessage == other.proposalMessage;
}
